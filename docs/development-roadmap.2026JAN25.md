# Development Roadmap (2026-01-25): Graph Backend

This document captures an architectural assessment of the new “graph” backend and proposes a concrete sequence of improvements with measurable success criteria.

## Context (Current Architecture)

`tenforty` currently ships with two computation engines behind the same Python API:

- **OTS backend (default/stable)**: Cython bindings around Open Tax Solver with a large line-level mapping layer (`src/tenforty/core.py`, `src/tenforty/models.py`, `src/tenforty/backends/ots.py`).
- **Graph backend (new)**: JSON “form graphs” executed by a Rust runtime (`crates/tenforty-graph/`) exposed to Python as `tenforty.graphlib`, wired via `src/tenforty/backends/graph.py`.

Separately, `tenforty-spec/` is a Haskell DSL intended to be the *source of truth* for tax logic, compiling to the JSON graph format.

## High-Level Assessment

### What’s strong

- **Layering is right**: Tax logic in DSL, execution in Rust, orchestration in Python.
- **Minimal runtime op set** (`crates/tenforty-graph/src/graph.rs`) keeps the engine stable and testable.
- **Cross-form linking** via `GraphSet.link()` is the correct abstraction for tax form dependency chains.
- **Autodiff + inverse solving** are cleanly layered and genuinely expand capabilities (marginal rates, solve-for-input workflows).
- **Parity tests against OTS** (Hypothesis-based) are an excellent de-risking strategy.

### Main gaps / risks

1) **Dependency completeness is not enforced yet**
- `src/tenforty/backends/graph.py:_load_linked_graph()` loads only `us_1040` (+ optionally `ca_540`), but `ca_540` imports additional forms (e.g., `ca_schedule_ca`, `ca_ftb_3514`).
- `GraphSet.link()` turns unresolved imports into `Input` nodes, and the Python backend sets all inputs to `0.0`, so missing dependencies can silently “work” but be incorrect.

2) **“DSL is source of truth” isn’t consistently honored in the runtime path**
- `src/tenforty/forms/us_1040_2025.json` is “hand-written” while `src/tenforty/forms/us_1040_2025_dsl.json` is generated by `tenforty-dsl`.
- The current graph backend loads `us_1040_{year}.json`, not the DSL-generated variant.

3) **Error handling in Python adapter is too permissive**
- Broad `try/except Exception: …` patterns and default-to-zero outputs make debugging and correctness enforcement harder.

4) **Latent correctness footguns in the Rust layer**
- `Op::Import` includes a `year`, but `GraphSet.link()` resolves imports by `(form_id, line)` only (year is effectively ignored).
- `Graph::topological_order()` panics on cycles (acceptable for generated graphs, but harsh for resilience/diagnostics).
- Some eval error variants lose detail (e.g., `NodeNotFound(0)`).
- Python/WASM bindings use `unsafe` lifetime extension tricks; likely OK today, but maintenance risk as complexity grows.

## Guiding Principles (for changes below)

- **Graph backend fails loudly** for missing dependencies and missing node names (no permissive/partial-evaluation mode).
- **Tax logic belongs in the DSL**; runtime ops remain minimal and generic.
- **Graphs must be dependency-complete** (imports resolved transitively) for production evaluation.
- **Correctness > performance** until parity and coverage targets are met; then optimize with JIT/batching.

## Roadmap: Proposed Changes + Success Criteria

The sequence below is intentionally staged so each step can be validated independently.

### Phase 1 — Make missing dependencies visible (Strictness + Diagnostics)

**Changes**
- Make the graph backend adapter always strict:
  - Detect unresolved imports before evaluation (via `GraphSet.unresolved_imports()`).
  - Fail with a clear error listing unresolved imports (form/line/year).
- Reduce exception swallowing in `src/tenforty/backends/graph.py`:
  - Replace broad `except Exception: pass` with narrowly-scoped exception handling (or allow errors to surface).
  - Prefer surfacing failures for missing nodes / bad mappings.

**Success criteria**
- Evaluating a state return with missing dependency graphs fails deterministically with actionable error text.
- Tests:
  - Add a unit test that asserts graph evaluation errors when unresolved imports exist.

**Verification**
- Run `pytest` and confirm the new strictness tests pass on environments with graph available.

---

### Phase 2 — Implement dependency-complete form loading (Resolver)

**Changes**
- Implement a form resolver that loads the transitive closure of imports for the requested evaluation:
  - Start with the base set (always federal `us_1040`, plus state form if requested).
  - Optionally expand based on non-zero user inputs (input-driven form selection).
  - Follow `imports` metadata in JSON recursively to add required forms.
- Wire resolver into `src/tenforty/backends/graph.py:_load_linked_graph()`.
- Prefer using the graph’s own `imports` list (top-level field) rather than scanning nodes for `Op::Import`, so resolution doesn’t depend on internal node structure.

**Success criteria**
- For CA returns, the loader includes `ca_540` plus all of its imported forms for that year, and linking results in `unresolved_imports() == []`.
- With the graph backend’s strict behavior, CA evaluation no longer depends on “import nodes become inputs set to 0”.
- Add targeted unit tests:
  - “CA graphs link cleanly” (imports resolved fully).
  - “GraphSet.link() contains expected prefixed nodes for imported forms.”

**Verification**
- Add a test that constructs a `GraphSet` using the resolver and asserts no unresolved imports for supported years/states.

---

### Phase 3 — Align runtime graphs with the DSL as the source of truth

**Changes**
- Decide on the canonical file naming convention for shipped graphs:
  - Option A: Always ship `*_{year}.json` as DSL output; remove/stop using `_dsl` suffix.
  - Option B: Keep both, but make the graph backend prefer DSL-generated graphs and treat hand-written graphs as temporary fallbacks.
- Add CI-style validation (tests or a script invoked by tests) that:
  - Ensures metadata `generated_by` matches expectations for “canonical” graphs (e.g., `tenforty-dsl`).
  - Ensures JSON schema consistency (required fields exist, node IDs unique, tables referenced exist, etc.).

**Success criteria**
- For 2025, the graph backend uses the DSL-generated graph as its primary source (or the canonical file is DSL-generated).
- There is a single, documented source of truth for each form/year used by the graph backend.
- A regression test fails if a shipped graph is “hand-written” when policy requires DSL generation.

**Verification**
- Add a test that reads graph meta for key forms and asserts `generated_by` meets policy.

---

### Phase 4 — Improve mapping fidelity (Natural inputs → graph nodes; outputs → API)

**Changes**
- Ensure `TaxReturnInput` fields are mapped consistently into graph node names:
  - For federal: expand beyond the current limited mapping set.
  - For state (CA): actually use `STATE_NATURAL_TO_LINE` in `GraphBackend._create_evaluator()`.
- Standardize naming conventions for node names so mapping doesn’t require per-form hacks (e.g., `us_1040_L2b_taxable_interest`).
- Add explicit handling for areas where OTS and the simplified graph differ (e.g., qualified dividends preferential rates):
  - Either encode the correct logic in DSL and ship the graph, or clearly document that the graph backend is a simplified model until implemented.

**Success criteria**
- For supported years, basic parity targets on covered inputs:
  - Federal: `abs(OTS - graph) <= $10` for `federal_total_tax` across a defined set of fields and ranges.
  - State CA: parity (or at minimum invariants like monotonicity) across defined ranges.
- For CA-specific inputs (`num_dependents`, `itemized_deductions`), changes in inputs change CA outputs in the expected direction (add monotonicity/invariant tests).

**Verification**
- Expand Hypothesis parity tests to include new mapped fields and to assert invariants where exact parity is not expected yet.

---

### Phase 5 — Tighten import semantics and runtime diagnostics (Rust)

**Changes**
- Decide how to treat `Op::Import.year`:
  - If multi-year mixed graphs will never be linked together: assert/enforce that imported year matches the linked set, and/or validate early.
  - If mixed-year support is desired: include year in resolution keys and update `GraphSet` to handle multiple versions safely.
- Replace cycle panic with an error return in topological sort, so diagnostics can report the cycle.
- Improve eval errors to preserve detail (e.g., missing node name in `NodeNotFound` paths).

**Success criteria**
- Linking validates import-year consistency (or fully supports year-aware resolution) with clear error messages.
- A malformed/cyclic graph yields a structured error (not a panic).
- Rust tests cover these error paths.

**Verification**
- Add/extend Rust unit tests in `crates/tenforty-graph/tests/` to cover:
  - Import-year mismatch behavior.
  - Cycle detection behavior.

---

### Phase 6 — Performance and scaling (after correctness gates)

**Changes**
- Use the existing JIT path (`crates/tenforty-graph/src/jit/*`) for batch evaluation from Python:
  - Expose a batch API that takes arrays and returns arrays (avoid per-node Python call overhead).
  - Optionally integrate with `evaluate_returns()` to evaluate the cartesian product more efficiently.
- Add benchmarks that reflect real usage:
  - `evaluate_returns()` throughput comparisons for interpreter vs JIT vs SIMD batch.

**Success criteria**
- For large grids (e.g., thousands of scenarios), graph backend is measurably faster than the current per-scenario Python loop.
- Benchmarks are stable and run in CI (or at least are documented and reproducible locally).

**Verification**
- Add a benchmark target and document expected speedups and hardware caveats.

---

### Phase 7 — Safety and packaging hardening

**Changes**
- Review the `unsafe` lifetime patterns in `crates/tenforty-graph/src/python.rs` and `crates/tenforty-graph/src/wasm.rs`:
  - Prefer safe ownership patterns if feasible (e.g., store runtime without forging `'static` refs).
  - Add tests that stress object lifetime edge cases from Python if possible.
- Ensure build flags and packaging defaults are clear:
  - Document `TENFORTY_BUILD_GRAPH`, graph-only installs, and platform limitations.

**Success criteria**
- No unsound lifetime assumptions remain unreviewed/undocumented.
- Users can reliably install either OTS-only or full (OTS + graph) builds with documented behavior.

**Verification**
- Add a small “lifecycle” Python test that creates/destroys graphs/runtimes repeatedly under pytest to catch obvious lifetime issues.

## Definition of “Graph Backend Ready” (Suggested)

The graph backend can be considered “ready” for broader default use when:

- **Dependency completeness**: linking yields zero unresolved imports for supported form/year/state combinations.
- **Correctness gates**: parity + invariant tests pass across agreed input domains for supported forms (federal + CA at minimum).
- **Diagnostics**: failures are actionable and not silently swallowed.
- **Stability**: linking and evaluation do not panic/crash on malformed inputs (return structured errors).

## Open Questions / Decisions Needed

- Should 2024 and earlier ever default to graph, or stay OTS-only until parity is strong?
- Canonical source for shipped graphs:
  - Are hand-written graphs allowed as bootstrapping, or must everything flow from DSL?
- Do we want multi-year mixed graph linking in one `GraphSet`, or should it be prohibited by design?
