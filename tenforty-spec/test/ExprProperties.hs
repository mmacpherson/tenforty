{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# OPTIONS_GHC -Wno-orphans #-}

module ExprProperties (spec) where

import Control.Monad (void)
import ReferenceEvaluator (evalGraphNode)
import TenForty
import TenForty.Expr
import Test.Hspec
import Test.QuickCheck

-- | Helper to evaluate an expression by wrapping it in a form
evalExpr :: Expr Dollars -> Double
evalExpr expr =
    let fid = "eval_expr"
        lid = "result"
        -- Create a form with a single computed line containing our expression
        mkForm = form fid 2024 $ void $ compute lid "Result" "Result" Interior expr
     in case mkForm of
            Left err -> error $ "Failed to construct form for expression: " ++ show err
            Right frm ->
                let graph = compileForm frm
                 in -- Evaluate with arbitrary inputs (none in this case, unless Expr has imports/lines)
                    -- We assume Exprs generated by Arbitrary don't have dangling refs
                    evalGraphNode graph Single 0 "result"

-- | Arbitrary instances for Expr
-- We only generate "closed" expressions (literals and ops) for now to avoid context issues
instance Arbitrary (Expr Dollars) where
    arbitrary = sized exprDollars

instance Arbitrary (Expr Rate) where
    arbitrary = sized exprRate

finiteDouble :: Gen Double
finiteDouble = arbitrary `suchThat` (\x -> not (isNaN x) && not (isInfinite x))

exprDollars :: Int -> Gen (Expr Dollars)
exprDollars 0 = Lit . Amount <$> finiteDouble
exprDollars n =
    oneof
        [ Lit . Amount <$> finiteDouble
        , Add <$> subD <*> subD
        , Sub <$> subD <*> subD
        , Mul <$> subD <*> subR
        , Max <$> subD <*> subD
        , Min <$> subD <*> subD
        , IfPos <$> subD <*> subD <*> subD
        , IfNeg <$> subD <*> subD <*> subD
        , IfGte <$> subD <*> subD <*> subD <*> subD
        ]
  where
    subD = exprDollars (n `div` 2)
    subR = exprRate (n `div` 2)

exprRate :: Int -> Gen (Expr Rate)
exprRate 0 = Lit . Amount <$> finiteDouble
exprRate n =
    oneof
        [ Lit . Amount <$> finiteDouble
        , Div <$> subD <*> subD
        ]
  where
    subD = exprDollars (n `div` 2)

spec :: Spec
spec = describe "Expr Properties" $ do
    it "eval (Lit a) == a" $ property $ forAll finiteDouble $ \d ->
        evalExpr (Lit (Amount d)) `shouldBe` d

    it "eval (a .+. b) == eval a + eval b" $ property $ \a b ->
        evalExpr (a .+. b) `shouldApproxEq` (evalExpr a + evalExpr b)

    it "eval (a .-. b) == eval a - eval b" $ property $ \a b ->
        evalExpr (a .-. b) `shouldApproxEq` (evalExpr a - evalExpr b)

    it "eval (a .*. b) == eval a * eval b" $ property $ \a b ->
        evalExpr (a .*. b) `shouldApproxEq` (evalExpr a * evalRate b)

    it "eval (maxE a b) == max (eval a) (eval b)" $ property $ \a b ->
        evalExpr (maxE a b) `shouldApproxEq` max (evalExpr a) (evalExpr b)

    it "eval (minE a b) == min (eval a) (eval b)" $ property $ \a b ->
        evalExpr (minE a b) `shouldApproxEq` min (evalExpr a) (evalExpr b)

    it "eval (ifPos c t e) matches logic" $ property $ \c t e ->
        let res = evalExpr (ifPos c t e)
            cond = evalExpr c
            expected = if cond > 0 then evalExpr t else evalExpr e
         in res `shouldApproxEq` expected

    it "eval (ifNeg c t e) matches logic" $ property $ \c t e ->
        let res = evalExpr (ifNeg c t e)
            cond = evalExpr c
            expected = if cond < 0 then evalExpr t else evalExpr e
         in res `shouldApproxEq` expected

    it "eval (ifGte a b t e) matches logic" $ property $ \a b t e ->
        let res = evalExpr (ifGte a b t e)
            valA = evalExpr a
            valB = evalExpr b
            expected = if valA >= valB then evalExpr t else evalExpr e
         in res `shouldApproxEq` expected

    it "eval (a ./. b) == safe division" $ property $ \a b ->
        let res = evalRate (a ./. b)
            va = evalExpr a
            vb = evalExpr b
            expected = if vb == 0 then 0 else va / vb
         in res `shouldApproxEq` expected

evalRate :: Expr Rate -> Double
evalRate r = evalExpr (Lit (Amount 1.0) `Mul` r)

shouldApproxEq :: Double -> Double -> Expectation
shouldApproxEq a b
    | abs (a - b) <= 1e-9 * max 1 (max (abs a) (abs b)) = pure ()
    | otherwise = expectationFailure $ "Expected " ++ show b ++ ", but got " ++ show a
